# HTTP

## {{ book.must }} Use HTTP Methods Correctly

Be compliant with the standardized HTTP method semantics summarized as follows:

###GET

- reads a resource or set of resource instances, respectively
- individual resources will usually generate a 404 if the resource does not exist;
  collection resources may return either 200 or 404 if the listing is empty
- must NOT have request body payload

###PUT:

- fully uploads an entity, i.e. provides a complete replacement by the resource representation
  passed as payload
- resource instance IDs are maintained by the client (either generated by the client or by the server
  in a previous POST request) and passed as a URL path segment
- PUT operations are usually only accepted by single resources, not collection resources, as
  PUT on a collection would imply replacing the entire collection
- usually robust against non-existence of the entity by implicit creation before update

###PATCH:

- partial upload, i.e. only a specific subset of resource fields are replaced
- usually not robust against non existence of the entity
- since implementing PATCH correctly is a bit tricky we strongly suggest to go for the following:

1. use PUT with a custom media type and only if that isn't sufficient anymore
2. use PATCH with [JSON Merge Patch](https://tools.ietf.org/html/rfc7386), a specialized media type 
   `application/merge-patch+json` that is a partial resource representation. If updates are too complex to be expressed
   with a merge patch, you should
3. use PATCH with [JSON Patch](http://tools.ietf.org/html/rfc6902), a specialized media type 
   `application/json-patch+json` that includes instructions on how to change the resource

###DELETE:

- deletes a resource instance
- DELETE operations are usually only accepted by single resources, not collection resources, as
  DELETE on a collection would imply deleting the entire collection
- should return either status 404 (Not found) or 410 (Gone) if the resource does not exist

###POST:

- creates a resource instance
- resource instance id(s) are created and maintained by server and returned with the output payload
- POST methods should be accepted by collection resources only
- more generally, POST should be used for scenarios that cannot be covered by the other methods.
  For instance, GET with complex (e.g. SQL like structured) query that needs to be passed as
  request body payload. In such cases, make sure to document the fact that POST is used as a
  workaround

###HEAD

- has exactly the same semantics as GET, but returns headers only, no body

###OPTIONS

- returns the available operations (methods) on a given endpoint (usually either as a comma separated list
  of methods or as a structured list of link templates)
- this operation is rarely implemented, though it could be used to self-describe the full functionality
  of a resource.


## {{book.must}}  HTTP Methods must Fulfill Safeness and Idempotency Properties

An operation can be...

- idempotent, i.e. operation will produce the same results if executed once or multiple times (note: this does not
  necessarily mean returning the same status code)
- safe, i.e. must not have side effects such as state changes

Method implementations must fulfill the following basic properties:

| HTTP method  |  safe  |  idempotent |
| --           |  --    |  --         |
| OPTIONS      |  Yes   |  Yes        |
| HEAD         |  Yes   |  Yes        |
| GET          |  Yes   |  Yes        |
| PUT          |  No    |  Yes        |
| POST         |  No    |  No         |
| DELETE       |  No    |  Yes        |
| PATCH        |  No    |  No         |

Please see also [Best Practices \[internal link\]](https://goo.gl/vhwh8a) for further hints on how to support the
different HTTP methods on resources.

## {{ book.must }} Use Meaningful HTTP Status Codes

###Success Codes:

| Code | Meaning | Methods |
| --   | --      | --                 |
| 200  | OK - this is the standard success response | All |
| 201  | Created - Returned on successful entity creation. You are free to return either an empty response or the created resource in conjunction with the Content-Location header.  Always set the Location header. | POST, PUT |
| 202  | Accepted - The request was successful and will be processed asynchronously. | POST, PUT, DELETE, PATCH |
| 204  | No content - There is no response body | PUT, DELETE |

###Redirection Codes:

| Code | Meaning | Methods |
| --   | --      | --                 |
| 301 | Moved Permamently - This and all future requests should be directed to the given URI. | All |
| 303 | See Other - The response to the request can be found under another URI using a GET method.  | PATCH, POST, PUT, DELETE |
| 304 | Not Modified - resource has not been modified since the date or version passed via request headers If-Modified-Since or If-None-Match. | GET |

###Client Side Error Codes:

| Code | Meaning | Methods |
| --   | --      | --                 |
| 400 | Bad request - generic / unknown error | All |
| 401 | Unauthorized - the users must log in (this often means “Unauthenticated”) | All |
| 403 | Forbidden - the user is not authorized to use this resource | All |
| 404 | Not found - the resource is not found | All |
| 405 | Method Not Allowed - the method is not supported, see OPTIONS | All |
| 406 | Not Acceptable - resource can only generate content not acceptable according to the Accept headers sent in the request | All |
| 408 | Request timeout - the server times out waiting for the resource | All |
| 409 | Conflict - returned if, e.g. when two clients try to create the same resource or if there are concurrent, conflicting updates | PUT, DELETE, PATCH |
| 412 | Precondition Failed - returned for conditional requests, e.g. If-Match if the condition failed. Used for optimistic locking. | PUT, DELETE, PATCH |
| 415 | Unsupported Media Type - e.g. clients sends request body without content type | PUT, DELETE, PATCH
| 422 | Unprocessable Entity - semantic error (as opposed to a syntax error which would usually trigger a 400) | POST, PUT, DELETE, PATCH |
| 423 | Locked - Pessimistic locking, e.g. processing states | PUT, DELETE, PATCH |
| 428 | Precondition Required - server requires the request to be conditional (e.g. to make sure that the “lost update problem” is avoided). | All |
| 429 | Too many requests - the client does not consider rate limiting and sent too many requests | All |

###Client Side Error Codes:

| Code | Meaning | Methods |
| --   | --      | --                 |
| 500 | Internal Server Error - a generic error indication for an unexpected server execution problem (here, client retry may be senseful) | All |
| 501 | Not Implemented -  server cannot fulfill the request (usually implies future availability, e.g. new feature). | All |
| 503 | Service Unavailable - server is (temporarily) not available (e.g. due to overload) -- client retry may be senseful. | All |

All error codes you can find at [W3C](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) and [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) or via https://httpstatuses.com/<error_code>.

## {{ book.must }} Providing Error Documentation

APIs should define the functional, business view and abstract from implementation aspects. Errors become a key element providing context and visibility into how to use an API. The error object should be extended by an application-specific error identifier since the HTTP status code often is not specific enough to articulate the domain error situation. For this reason, we use a standardized error return object definition — see [*Use Common Error Return Objects*](../common-data-objects/CommonDataObjects.md#must-use-common-error-return-objects) below.

The OpenAPI specification shall include definition of all error status codes and error descriptions that possibly will be returned; they are part of the interface definition and provide important information for service clients to handle exceptional situations and support troubleshooting. You should also think about a troubleshooting board — it is part of the associated online API documentation, provides information and handling guidance on application-specific errors and is referenced via links of the API definition. This can reduce service support tasks and contribute to service client and provider performance.

## {{ book.should }} Reducing Bandwidth Needs and Improving Responsiveness

APIs should support techniques for reducing bandwidth based on client needs. This holds for APIs
that (might) have high payloads and/or are used in high-traffic scenarios like the public Internet
and telecommunication networks. Typical examples are APIs used by mobile web app clients with
(often) less bandwidth connectivity. (Zalando is a “Mobile “First” company, so be mindful of this
point.)

Common techniques include:

* gzip compression
* querying field filters to retrieve a subset of resource attributes
* `ETag` (and If-[None-]Match) headers to avoid refetch of unchanged resources
* pagination for incremental access of larger (result) lists

Each of these items is described in greater detail below.

## {{ book.should }} gzip Compression

Compress the payload of your API’s responses with gzip (GNU zip), unless there’s a good reason not
to — for example,  you are serving so many requests that the time to compress becomes a bottleneck.
This helps to transport data faster over the network (fewer bytes) and makes frontends respond faster.

Though gzip compression might be the default choice for server payload, the server should also support payload without compression and its client control via Accept-Encoding request header -- see also [RFC 7231 Section 5.3.4](http://tools.ietf.org/html/rfc7231#section-5.3.4). The server should indicate used gzip
compression via the Content-Encoding header.

## {{ book.should }} Support Filtering of Resource Fields

Depending on your use case and payload size, you can significantly reduce network bandwidth need by support filtering of returned entity fields. Here, the client can determine the subset of fields he wants to receive via the fields query parameter — example see [Google AppEngine API's partial response](https://cloud.google.com/appengine/docs/python/taskqueue/rest/performance#partial-response):

### Unfiltered

```http
GET http://api.example.org/resources/123 HTTP/1.1

HTTP/1.1 200 OK
Content-Type: application/x.person+json

{
  "id": "cddd5e44-dae0-11e5-8c01-63ed66ab2da5",
  "name": "John Doe",
  "address": "1600 Pennsylvania Avenue Northwest, Washington, DC, United States",
  "birthday": "1984-09-13",
  "partner": {
    "id": "1fb43648-dae1-11e5-aa01-1fbc3abb1cd0",
    "name": "Jane Doe",
    "address": "1600 Pennsylvania Avenue Northwest, Washington, DC, United States",
    "birthday": "1988-04-07"
  }
}
```

### Filtered

```http
GET http://api.example.org/resources/123?fields=(name,partner(name)) HTTP/1.1

HTTP/1.1 200 OK
Content-Type: application/x.person+json;fields=(name,partner(name))

{
  "name": "John Doe",
  "partner": {
    "name": "Jane Doe"
  }
}
```

The approach we recommend for field is a Zalando Github project,
[json-fields](https://github.com/zalando/json-fields). It defines a formal grammar for the ANTLR
 parser generator and provides a ready-to use library for Java / Jackson based projects
 ([Maven link](http://mvnrepository.com/artifact/org.zalando.guild.api/json-fields-jackson)).
Teams that use other JSON serializers are encouraged to contribute to the open source project and
create their own parser / framework based on this grammar.

Other approaches we have considered are JSONPath or GraphQL. While they have advantages, neither of
them can easily be plugged into an existing serialization process, so they require an additional,
manual serialization process, whereas the above solution addresses our main filter use cases and
can easily be introduced with a minimum of effort.

Hint: OpenAPI doesn't allow you to formally specify whether depending on a given parameter will
return different parts of the specified result schema. Explain this in English in the parameter
description.

## {{ book.could }} Support the ETag Header

If a resource changes, the contents of the [`ETag`](https://en.wikipedia.org/wiki/HTTP_ETag) header
must also change. Combined with the `If-Match` and `If-None-Match` headers, the `ETag` header allows
for:

* caching of entities
* optimistic locking

Its possible contents:

* the entity’s version number
* hash of the response body
* hash of the entity’s last modified field
